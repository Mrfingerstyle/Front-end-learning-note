<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <pre>资料来源 饥人谷</pre>
    <script>
        /*
        JS三座大山
            原型 
            this
            AJAX

        JS公式
            对象.__proto__ === 其构造函数.prototype

        根公理
            Object.prototype是所有对象的 直接或间接 原型
            let a = []
            a.__proto__.__proto__ === Object.prototype
            let b = {}
            b.__proto__ === Object.prototype

        函数公理
            所有函数都是由Function构造
            任何函数.__proto__ === Function.prototype
            任意函数包括 Object Array Function 
            Array.__proto__ === Function.prototype
            Object.__proto__ === Function.prototype
            Function.__proto__ === Function.prototype
        
        解释1
            xxx 的原型
            Object的原型是Object.__proto__
            的原型 等价于 .__proto__
            中文的原型无法区分__proto__ 和 prototype
            所以只能约定 原型默认是__proto__
            只不过__proto__正好等于某个函数的prototype

        解释2
            案例 
            [1, 2, 3]的原型是Array.prototype 
            又说 Object.prototype 是所有对象的原型 
            那么为什么Object.prototype不是[1, 2, 3]的原型
            解释
            原型分两种 直接原型和间接原型
            对于普通对象来说 Object.prototype是直接原型
            对于数组 函数来说 Object.prototype是间接原型
            let a = []
            a.__proto__.__proto__ === Object.prototype
            let b = {}
            b.__proto__ === Object.prototype

        解释3 
            Object.prototype 是所有对象的原型 
            Object由Function创造
            所以 Function创造Object.prototype
            推论 Function是万物之源
            解释
            注意Object.prototype 地址 和 Object.prototype 对象的区别
            Function创造了Object.prototype的地址 
            对象里面从来都不会包含另一个对象 只会包含另一个对象的地址

        */
    </script>
</body>
</html>